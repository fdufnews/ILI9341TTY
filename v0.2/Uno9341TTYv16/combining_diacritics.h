#ifndef COMBINING_DIACRITICS_H
#define COMBINING_DIACRITICS_H

// This file is automatically generated, do not edit it,
// see ./prepare_fonts/README.md for more information.
// 0x000300-0x00036F: Combining Diacritical Marks 
// Plus some extra combining marks from other blocks
// Plus some custom combining marks not in unicode

#define COMBINING_GRAVE_ACCENT                           (0x0)
#define COMBINING_ACUTE_ACCENT                           (0x1)
#define COMBINING_CIRCUMFLEX_ACCENT                      (0x2)
#define COMBINING_TILDE                                  (0x3)
#define COMBINING_MACRON                                 (0x4)
#define COMBINING_OVERLINE                               (0x5)
#define COMBINING_BREVE                                  (0x6)
#define COMBINING_DOT_ABOVE                              (0x7)
#define COMBINING_DIAERESIS                              (0x8)
#define COMBINING_HOOK_ABOVE                             (0x9)
#define COMBINING_RING_ABOVE                             (0xA)
#define COMBINING_DOUBLE_ACUTE_ACCENT                    (0xB)
#define COMBINING_CARON                                  (0xC)
#define COMBINING_VERTICAL_LINE_ABOVE                    (0xD)
#define COMBINING_DOUBLE_VERTICAL_LINE_ABOVE             (0xE)
#define COMBINING_DOUBLE_GRAVE_ACCENT                    (0xF)
#define COMBINING_CANDRABINDU                            (0x10)
#define COMBINING_INVERTED_BREVE                         (0x11)
#define COMBINING_TURNED_COMMA_ABOVE                     (0x12)
#define COMBINING_COMMA_ABOVE                            (0x13)
#define COMBINING_REVERSED_COMMA_ABOVE                   (0x14)
#define COMBINING_COMMA_ABOVE_RIGHT                      (0x15)
#define COMBINING_GRAVE_ACCENT_BELOW                     (0x16)
#define COMBINING_ACUTE_ACCENT_BELOW                     (0x17)
#define COMBINING_LEFT_TACK_BELOW                        (0x18)
#define COMBINING_RIGHT_TACK_BELOW                       (0x19)
#define COMBINING_LEFT_ANGLE_ABOVE                       (0x1A)
#define COMBINING_HORN                                   (0x1B)
#define COMBINING_LEFT_HALF_RING_BELOW                   (0x1C)
#define COMBINING_UP_TACK_BELOW                          (0x1D)
#define COMBINING_DOWN_TACK_BELOW                        (0x1E)
#define COMBINING_PLUS_SIGN_BELOW                        (0x1F)
#define COMBINING_MINUS_SIGN_BELOW                       (0x20)
#define COMBINING_PALATALIZED_HOOK_BELOW                 (0x21)
#define COMBINING_RETROFLEX_HOOK_BELOW                   (0x22)
#define COMBINING_DOT_BELOW                              (0x23)
#define COMBINING_DIAERESIS_BELOW                        (0x24)
#define COMBINING_RING_BELOW                             (0x25)
#define COMBINING_COMMA_BELOW                            (0x26)
#define COMBINING_CEDILLA                                (0x27)
#define COMBINING_OGONEK                                 (0x28)
#define COMBINING_VERTICAL_LINE_BELOW                    (0x29)
#define COMBINING_BRIDGE_BELOW                           (0x2A)
#define COMBINING_INVERTED_DOUBLE_ARCH_BELOW             (0x2B)
#define COMBINING_CARON_BELOW                            (0x2C)
#define COMBINING_CIRCUMFLEX_ACCENT_BELOW                (0x2D)
#define COMBINING_BREVE_BELOW                            (0x2E)
#define COMBINING_INVERTED_BREVE_BELOW                   (0x2F)
#define COMBINING_TILDE_BELOW                            (0x30)
#define COMBINING_MACRON_BELOW                           (0x31)
#define COMBINING_LOW_LINE                               (0x32)
#define COMBINING_DOUBLE_LOW_LINE                        (0x33)
#define COMBINING_TILDE_OVERLAY                          (0x34)
#define COMBINING_SHORT_STROKE_OVERLAY                   (0x35)
#define COMBINING_LONG_STROKE_OVERLAY                    (0x36)
#define COMBINING_SHORT_SOLIDUS_OVERLAY                  (0x37)
#define COMBINING_LONG_SOLIDUS_OVERLAY                   (0x38)
#define COMBINING_RIGHT_HALF_RING_BELOW                  (0x39)
#define COMBINING_INVERTED_BRIDGE_BELOW                  (0x3A)
#define COMBINING_SQUARE_BELOW                           (0x3B)
#define COMBINING_SEAGULL_BELOW                          (0x3C)
#define COMBINING_X_ABOVE                                (0x3D)
#define COMBINING_VERTICAL_TILDE                         (0x3E)
#define COMBINING_DOUBLE_OVERLINE                        (0x3F)
#define COMBINING_GRAVE_TONE_MARK                        (0x40)
#define COMBINING_ACUTE_TONE_MARK                        (0x41)
#define COMBINING_GREEK_PERISPOMENI                      (0x42)
#define COMBINING_GREEK_KORONIS                          (0x43)
#define COMBINING_GREEK_DIALYTIKA_TONOS                  (0x44)
#define COMBINING_GREEK_YPOGEGRAMMENI                    (0x45)
#define COMBINING_BRIDGE_ABOVE                           (0x46)
#define COMBINING_EQUALS_SIGN_BELOW                      (0x47)
#define COMBINING_DOUBLE_VERTICAL_LINE_BELOW             (0x48)
#define COMBINING_LEFT_ANGLE_BELOW                       (0x49)
#define COMBINING_NOT_TILDE_ABOVE                        (0x4A)
#define COMBINING_HOMOTHETIC_ABOVE                       (0x4B)
#define COMBINING_ALMOST_EQUAL_TO_ABOVE                  (0x4C)
#define COMBINING_LEFT_RIGHT_ARROW_BELOW                 (0x4D)
#define COMBINING_UPWARDS_ARROW_BELOW                    (0x4E)
#define COMBINING_GRAPHEME_JOINER                        (0x4F)
#define COMBINING_RIGHT_ARROWHEAD_ABOVE                  (0x50)
#define COMBINING_LEFT_HALF_RING_ABOVE                   (0x51)
#define COMBINING_FERMATA                                (0x52)
#define COMBINING_X_BELOW                                (0x53)
#define COMBINING_LEFT_ARROWHEAD_BELOW                   (0x54)
#define COMBINING_RIGHT_ARROWHEAD_BELOW                  (0x55)
#define COMBINING_RIGHT_ARROWHEAD_AND_UP_ARROWHEAD_BELOW (0x56)
#define COMBINING_RIGHT_HALF_RING_ABOVE                  (0x57)
#define COMBINING_DOT_ABOVE_RIGHT                        (0x58)
#define COMBINING_ASTERISK_BELOW                         (0x59)
#define COMBINING_DOUBLE_RING_BELOW                      (0x5A)
#define COMBINING_ZIGZAG_ABOVE                           (0x5B)
#define COMBINING_DOUBLE_BREVE_BELOW                     (0x5C)
#define COMBINING_DOUBLE_BREVE                           (0x5D)
#define COMBINING_DOUBLE_MACRON                          (0x5E)
#define COMBINING_DOUBLE_MACRON_BELOW                    (0x5F)
#define COMBINING_DOUBLE_TILDE                           (0x60)
#define COMBINING_DOUBLE_INVERTED_BREVE                  (0x61)
#define COMBINING_DOUBLE_RIGHTWARDS_ARROW_BELOW          (0x62)
#define COMBINING_LATIN_SMALL_LETTER_A                   (0x63)
#define COMBINING_LATIN_SMALL_LETTER_E                   (0x64)
#define COMBINING_LATIN_SMALL_LETTER_I                   (0x65)
#define COMBINING_LATIN_SMALL_LETTER_O                   (0x66)
#define COMBINING_LATIN_SMALL_LETTER_U                   (0x67)
#define COMBINING_LATIN_SMALL_LETTER_C                   (0x68)
#define COMBINING_LATIN_SMALL_LETTER_D                   (0x69)
#define COMBINING_LATIN_SMALL_LETTER_H                   (0x6A)
#define COMBINING_LATIN_SMALL_LETTER_M                   (0x6B)
#define COMBINING_LATIN_SMALL_LETTER_R                   (0x6C)
#define COMBINING_LATIN_SMALL_LETTER_T                   (0x6D)
#define COMBINING_LATIN_SMALL_LETTER_V                   (0x6E)
#define COMBINING_LATIN_SMALL_LETTER_X                   (0x6F)
#define COMBINING_SEMIVOICED_SOUND_MARK                  (0x70)
#define COMBINING_VOICED_SOUND_MARK                      (0x71)
#define COMBINING_EMPHASIS_MARK                          (0x72)
#define COMBINING_EXCLAMATION_MARK                       (0x73)
#define COMBINING_QUESTION_MARK                          (0x74)
#define COMBINING_DEVANAGARI_SIGN_INVERTED_CANDRABINDU   (0x75)
#define COMBINING_DEVANAGARI_SIGN_CANDRABINDU            (0x76)
#define COMBINING_DEVANAGARI_SIGN_ANUSVARA               (0x77)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_OE               (0x78)
#define COMBINING_DEVANAGARI_SIGN_NUKTA                  (0x79)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_U                (0x7A)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_UU               (0x7B)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_VOCALIC_R        (0x7C)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_VOCALIC_RR       (0x7D)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_CANDRA_E         (0x7E)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_SHORT_E          (0x7F)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_E                (0x80)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_AI               (0x81)
#define COMBINING_DEVANAGARI_STRESS_SIGN_UDATTA          (0x82)
#define COMBINING_DEVANAGARI_STRESS_SIGN_ANUDATTA        (0x83)
#define COMBINING_DEVANAGARI_GRAVE_ACCENT                (0x84)
#define COMBINING_DEVANAGARI_ACUTE_ACCENT                (0x85)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_CANDRA_LONG_E    (0x86)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_UE               (0x87)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_UUE              (0x88)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_VOCALIC_L        (0x89)
#define COMBINING_DEVANAGARI_VOWEL_SIGN_VOCALIC_LL       (0x8A)

// Defined codes range from 0x300+ 0..139
// The following extra codes were defined:
// 0x309A → 0; SEMIVOICED SOUND MARK (JAPANESE)
// 0x3099 → 1; VOICED SOUND MARK (JAPANESE)
// 0x55B → 2; EMPHASIS MARK (ABOVE)
// 0x55C → 3; EXCLAMATION MARK (ABOVE)
// 0x55E → 4; QUESTION MARK (ABOVE)
// 0x900 → 5; DEVANAGARI SIGN INVERTED CANDRABINDU (ABOVE)
// 0x901 → 6; DEVANAGARI SIGN CANDRABINDU (ABOVE)
// 0x902 → 7; DEVANAGARI SIGN ANUSVARA (ABOVE)
// 0x93A → 8; DEVANAGARI VOWEL SIGN OE (ABOVE)
// 0x93C → 9; DEVANAGARI SIGN NUKTA (BELOW)
// 0x941 → 10; DEVANAGARI VOWEL SIGN U (BELOW)
// 0x942 → 11; DEVANAGARI VOWEL SIGN UU (BELOW)
// 0x943 → 12; DEVANAGARI VOWEL SIGN VOCALIC R (BELOW)
// 0x944 → 13; DEVANAGARI VOWEL SIGN VOCALIC RR (BELOW)
// 0x945 → 14; DEVANAGARI VOWEL SIGN CANDRA E (ABOVE)
// 0x946 → 15; DEVANAGARI VOWEL SIGN SHORT E (ABOVE)
// 0x947 → 16; DEVANAGARI VOWEL SIGN E (ABOVE)
// 0x948 → 17; DEVANAGARI VOWEL SIGN AI (ABOVE)
// 0x951 → 18; DEVANAGARI STRESS SIGN UDATTA (ABOVE)
// 0x952 → 19; DEVANAGARI STRESS SIGN ANUDATTA (BELOW)
// 0x953 → 20; DEVANAGARI GRAVE ACCENT (ABOVE)
// 0x954 → 21; DEVANAGARI ACUTE ACCENT (ABOVE)
// 0x955 → 22; DEVANAGARI VOWEL SIGN CANDRA LONG E (ABOVE)
// 0x956 → 23; DEVANAGARI VOWEL SIGN UE (ABOVE)
// 0x957 → 24; DEVANAGARI VOWEL SIGN UUE (BELOW)
// 0x962 → 25; DEVANAGARI VOWEL SIGN VOCALIC L (BELOW)
// 0x963 → 26; DEVANAGARI VOWEL SIGN VOCALIC LL (BELOW)
#define ABOVE       (0)
#define BELOW       (1)
#define OVERLAY     (2)
#define LEFT        (3)
#define RIGHT       (4)
#define ABOVE_LEFT  (5)
#define ABOVE_RIGHT (6)
#define BELOW_LEFT  (7)
#define BELOW_RIGHT (8)
#define GREEK       (9)
#define JAPANESE    (10)
#define UNDEFINED (0xFF)
#define MAX_DIACRITIC_CODE (138)

// Diacritic bitmaps are organized into rows, with leftmost pixel in the lowest
// -order bit. Bitmaps of varying height are packed consecutively. To retrieve
// a bitmap, unpack the information in the `diacritic_info' array.

static const byte diacritic_bitmaps[] PROGMEM = {  8,  4,  8, 16, 20,  8, 18,
 44, 28, 62, 28, 34,  8, 20,  8, 16, 12, 28, 20, 28, 18, 36,  8, 20,  8,  8, 20,
 20, 36, 18, 28, 34,  8, 34, 28,  4, 12, 12,  8,  8,  4, 12,  8, 12,  8,  4, 12,
  4,  8, 12, 28, 16, 24,  4, 24, 28,  8,  8, 28,  8, 28,  8, 28, 56, 32, 48, 16,
 32, 28, 16, 28,  4, 34, 62, 20, 42, 62,  0, 62, 15, 31,  3, 12,  3, 12, 48, 24,
  4, 24, 30, 18, 30, 42, 20, 20,  8, 20,  4,  8,  4,  8, 33,  4,  8, 12,  4, 28,
 28,  4, 29, 46,  8,  2, 29, 46, 16, 50, 12, 50, 12, 20, 62, 20, 42, 28,  8, 16,
 62, 16, 42, 28,  4, 62,  4,  1, 59, 17, 20,  8, 28,  8, 20, 42, 20, 16, 28,  4,
 56, 40, 56, 16,  8, 32, 16, 16, 32,  8, 56, 32, 20, 36, 24, 42, 28, 28, 42, 32,
  8,  8,  8, 24, 36, 48, 12, 36, 24, 56,  4, 24, 56, 28, 56, 24, 36, 16, 28,  4,
  8,  4, 24, 22, 16, 16, 16, 62, 32, 16, 16, 32, 62, 28, 34, 24, 36, 28, 62, 34,
 50, 26, 60, 50, 58, 60,};

// The `diacritic_info` array decribes diacritics, starting at 0x300, in two-
// byte codes. The first byte is the starting index for the bitmap information
// in `diacritic_bitmaps`, or 0xFF is the diacritic is not supported. The
// second byte contains the height (minus 1), padding (1=no padding), and
// location (see #defined location codes above), packed into 2, 2, and 4 bits,
// respectively.

static const byte diacritic_info[] PROGMEM = {  0, 96,  2, 96,  4, 96,  6, 96,
  8, 32,  9, 32, 10, 96, 12, 32, 13, 32, 14,144, 17,128, 20, 96, 22, 96, 24, 96,
 26, 96, 28, 96, 30,160, 33, 96, 35, 96, 37, 96, 39,160, 37,102,  0, 97,  2, 97,
 42,161, 45,161, 48, 96, 50,102, 52,161, 55, 97, 57, 97, 59,161, 62, 33, 63, 81,
 65,145, 12, 33, 13, 33, 17,145, 37, 97, 68, 81, 70, 81, 24, 97, 72, 97, 74, 97,
 22, 97,  4, 97, 10, 97, 33, 97,  6, 97,  8, 33,  9, 33, 76,161,  6, 98, 79, 34,
 80, 34, 81, 98, 83,162, 86,161,255,192, 89,161, 92, 97, 94,160, 97,208, 76,160,
  0, 96,  2, 96,  6,105,255,192,101,160,104, 97, 72, 96,106, 97, 26, 97, 48, 97,
108,208,112,208,116,224,120,161,123,161,255,192,126,160, 52,160,129, 96, 94,161,
131,161,126,161,134,161, 86,160, 12, 38,137,225,141,161,144,160,255,192,255,192,
255,192,255,192,255,192,255,192,255,192,255,192,255,192,255,192,255,192,255,192,
255,192,255,192,255,192,255,192,255,192,255,192,255,192,255,192,147,154,150,218,
154, 96,156,160,159,160,162, 96,164, 96,166, 16,167, 80,169, 33,170,145,173,145,
176,145,179,145,182, 80,184,144,187, 80,189,144,192, 96,194, 33,195, 96,197, 96,
199,144,202, 96,204,145,207,145,210,145,};




////////////////////////////////////////////////////////////////////////////////
/** Stamp combining diacritic over previously drawn character
 */
void stamp_diacritic(byte index,byte nrow,byte pad,byte location) {
  
  // Get diacritic bitmap
  byte rowdata[nrow];
  for (int i=0; i<nrow; i++)
    rowdata[i]=pgm_read_byte(diacritic_bitmaps+index+i);
  
  // Patch for now
  if (location==JAPANESE) location=ABOVE; 
  
  // Hmm, need to clean up character bitmap
  for (byte i=0; i<CH; i++) char_bitmap[i]&=0b111111;
  
  if (location==GREEK) {
    // Greek breathing marks are above for lower-case and above-left for upper-
    // case. Handle this by routing to ABOVE or ABOVE_LEFT depending on 
    // character height. Get height by starting at top, and moving down until
    // a non-empty row is found.
    int i=CH-1;
    while (char_bitmap[i]==0 && i>0) i--;
    location = i>MIDLINE? ABOVE_LEFT : ABOVE;
  }
  if (location==ABOVE_RIGHT || location==BELOW_RIGHT) {
    // Move the mark as far right as possible. 
    // Find rightmost column of diacritic bitmap
    byte mask = 0;
    int i=0;
    for (; i<nrow; i++) mask |= rowdata[i];
    mask <<= (8-CW);
    byte counter = 0;
    // Shift left until we get a 1 in the top bit
    while ((int8_t)(mask)>0) {mask<<=1; counter++;}
    // "Counter" now tells us how many bits we need to shift to meet right column
    for (i=0; i<nrow; i++) rowdata[i]<<=counter;
    // Reduce to the ABOVE/BELOW case
    location = (location==ABOVE_RIGHT)? ABOVE: BELOW;
  }
  else if (location==ABOVE_LEFT || location==BELOW_LEFT ) {
    // Move mark as far left as possible
    byte mask = 0;
    int i=0;
    for (; i<nrow; i++) mask |= rowdata[i];
    byte counter = 0;
    // Shift right until we get a 1 in the top bit
    while (mask) {mask>>=1; counter++;}
    // "Counter" now tells us how many bits we need to shift to meet right column
    for (i=0; i<nrow; i++) rowdata[i]>>=counter;
    location = (location==ABOVE_RIGHT)? ABOVE: BELOW;
  }
  if (location==ABOVE) {
    // Find top of character
    int i=CH-1;
    while (i>=MIDLINE && !char_bitmap[i]) i--;
    // Handle i,j as special cases
    if (char_bitmap[i]==0b00001000 && char_bitmap[i-1]==0) {
      // diacritics overwrite the tittle on these
      char_bitmap[i] = 0;
      while (i>=MIDLINE && !char_bitmap[i]) i--;
    }
    // i will stop at first non-empty row
    // ideally, diacritic should be placed above this
    // pad matters
    // pad 0 = overlap top
    // pad 1 = abut top
    // pad 2 = leave spacing
    byte diacritic_start_row = i+pad;
    int last_row = (nrow-1)+diacritic_start_row;
    if (last_row>=CH) {
      // Not enough space
      int need_space = last_row - (CH-1);
      while (need_space>0 && SUCCESS==shorten_down_top()                      ) {need_space--; diacritic_start_row--;}
      while (need_space>0 && SUCCESS==nudge_down_top()                        ) {need_space--; diacritic_start_row--;}
      while (need_space>0 && SUCCESS==smash_diacritics_down_top_conservative()) {need_space--; diacritic_start_row--;}
      while (need_space>0 && SUCCESS==smash_diacritics_down_top_aggressive()  ) {need_space--; diacritic_start_row--;}
      while (need_space>0 && pad>0) {pad--; need_space--; diacritic_start_row--;}
    } else if (i==MIDLINE-1) {
      byte isempty = 1;
      do {
        if (char_bitmap[i]) {
          isempty = 0;
          break;
        }
        i--;
      } while (i>=0);
      if (isempty) diacritic_start_row = CH - 1 - nrow;
    
    }
    // We might run out of space, for now just stop drawing if this happens
    for (int i=0; i<nrow; i++) {
      if (i+diacritic_start_row >= CH) break;
      char_bitmap[i+diacritic_start_row] |= rowdata[i];
    }
  }
  else if (location==BELOW) {
    // Find base of character
    int i=0;
    while (i<CH && !char_bitmap[i]) i++;
    if (i < nrow + pad - 1) {
      int need_space = nrow + pad - 1 - i - 2;
      while (need_space>0 && SUCCESS==shorten_up_base()                      ) need_space--;
      while (need_space>0 && SUCCESS==nudge_up_base()                        ) need_space--;
      while (need_space>0 && SUCCESS==smash_diacritics_up_base_conservative()) need_space--;
      while (need_space>0 && SUCCESS==smash_diacritics_up_base_aggressive()  ) need_space--;
      while (need_space>0 && pad>0) {pad--; need_space--;}
    }
    byte r = 0;
    for (int i=0; i<nrow; i++) {if (r+i>=CH) break; char_bitmap[r+i] |= rowdata[i];}
  }
  else if (location==OVERLAY) for (int i=0; i<nrow; i++) char_bitmap[MIDLINE+i-nrow/2] |= rowdata[i];
}

////////////////////////////////////////////////////////////////////////////////
// Combine mark from the combining diacritics unicode block
void combine_diacritic(byte diacritic_index) {
  if (diacritic_index>MAX_DIACRITIC_CODE) return;
  byte index = pgm_read_byte(diacritic_info + diacritic_index*2);
  if (index==UNDEFINED) return;
  byte info = pgm_read_byte(diacritic_info + diacritic_index*2 + 1);
  byte loc  = info & 0b1111;
  byte pad  = (info>>4) & 0b11;
  byte nrow = ((info>>6) & 0b11) + 1;
  stamp_diacritic(index,nrow,pad,loc);
}

////////////////////////////////////////////////////////////////////////////////
/** Handling combining diacritic. 
 *  There must be a recently-drawn charater with which to combine. 
 *  If there isn't, treat it as combining with an empty space. 
 */
int _combiningdiacriticalmarks(unsigned int c) {
  if (combining_ok) {row=prev_row; col=prev_col;}
  else clear_bitmap();
  combine_diacritic(c);
  new_combining_ok = 1;
  return LOADED;
}


#endif // COMBINING_DIACRITICS
