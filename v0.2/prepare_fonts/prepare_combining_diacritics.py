#!/usr/bin/env python3
'''
Prepares data and some of the source code to handle combining diacritics

- Diacritic bitmaps are squished into a byte array, one byte per pixel row. 
- Diacritics are define with 2 bytes of information:
    - An info code, which packs height, padding, and location in 2,2,4 bits.
    - An index into the bitmap data for the start of this diacritic
    
The combining diacritics block starts at 0x300 and continues to 0x036F.
The simplest way to extend the table of combining diacritics is to pretend
that this block continues on to 0x03FF. This range actually belongs to Greek
and Coptic, so the unicode mapping code won't send any codes in this range. 



'''
from CONFIG import *
from font_utilities import *

# Start (inclusive) and stop (exclusive) of combining diacritical marks block.
BLOCK_STARTS  = 0x300
BLOCK_ENDS    = 0x370

headername = diacritics_filename.split('/')[-1].split('.')[0].upper()
SRC = "#ifndef %s_H\n"%headername
SRC+= "#define %s_H\n"%headername
SRC+= '''
// This file is automatically generated, do not edit it,
// see ./prepare_fonts/README.md for more information.
// 0x000300-0x00036F: Combining Diacritical Marks 
// Plus some extra combining marks from other blocks
// Plus some custom combining marks not in unicode
'''


# Several diacritics are essentially the same, just positioned differently.
# Our implementation separates the bitmap for the diacritic from its positioning
# information
location_codes = ('ABOVE_LEFT ABOVE_RIGHT BELOW_LEFT BELOW_RIGHT'
                 ' LEFT RIGHT ABOVE BELOW OVERLAY').split()

# Some diacritics are described differently in the unicode names for pre-
# composed characters.
rename = {
    'OVERLINE':'HLINE',
    'LOW LINE':'HLINE BELOW',
    'KATAKANA-HIRAGANA':'',
}

# Read in the diacritics file
all_marks      = []    # List of parsed diacritics in order appearing in file
bitinfo        = {}    # name → bitmap rows 
padinfo        = {}    # name → Padding, in pixels, for each diacritic
aliases        = {}    # name → base name for aliased diacritics
active         = None  # Diacritic currently being read
alreadydefined = False # Flag set if diacritic already defined

# Grab file contents
diacritic_info = ''.join(open(combining_modifiers_file,'r')\
  .readlines()).split('\n')

# Parse the diacritics bitmap file
for lineno,line in enumerate(diacritic_info):
    # Diacritics start with a line containing the unicode point in hex
    if line.startswith('0x'):
        # Start reading information for new diacritic
        # First word is the unicode point
        # Second word is the mark itself, as a character
        # Remainder of the line is the unicode name
        words = line.split()
        code  = int(words[0][2:],16)
        char  = words[1][-1]
        name  = ' '.join(words[2:])
        #if not name.split(' ')[0]=='COMBINING':
        #  raise ValueError(
        #    'Line %d: '%lineno+
        #    'Expected modifier name to start with COMBINING\n'+
        #    'line is '+line+
        #    '\n'+name.split(' ')[0])
        
        # Switch naming conventions for some codes
        for k,v in rename.items(): name = name.replace(k,v)
        name = ' '.join(name.split(' ')[1:])
        
        # Infer location from the name (ad-hoc, with some special cases).
        location = 'ABOVE'
        for l in location_codes:
            if name.endswith(l.replace('_',' ')):
                location = l
                name = ' '.join(name.split(' ')[:-len(l.split('_'))])
                break 
        if   'GREEK DIALYTIKA TONOS' in name: location = 'ABOVE'
        elif 'VOICED SOUND MARK'     in name: location = 'JAPANESE'
        elif 'GREEK'                 in name: location = 'GREEK'
        elif 'CEDILLA'               in name: location = 'BELOW'
        elif 'OGONEK'                in name: location = 'BELOW'
        elif name=='HORN'                   : location = 'ABOVE_RIGHT'
        
        # Set the `active` variable to start reading diacritic information
        active = (code,char,name,location)
      
        # Create space to store bitmap, if needed
        # The the name is already associated with an existing bitmap 
        # (eg tilde above vs tilde belo), we'll raise an error if we encounter
        # bitmap data. 
        alreadydefined = name in bitinfo and len(bitinfo[name])>0
        if not alreadydefined: bitinfo[name] = []
        
        # Add this diacritic to the list of processed diacritics
        all_marks.append(active)
        
        # The default padding is 1 pixel; This may be overridendiacritics
        padinfo[code]=1
        
    elif active!=None:
        #  Read bitmap, alias, or padding information for current diacritic

        if line.startswith('pad'):
            # Set the padding, in pixels. Default is 1
            code = active[0]
            padinfo[code] = int(line.split('pad')[1])
            
        elif line.startswith('alias'):
            # Mark this diacritic as an alias of another diacritic
            # For now, we juts store a mapping from diacritic name to the name
            # it is aliased to. We'll handle these later
            alias = line.split('alias')[1].strip().upper()
            name  = active[2]
            aliases[name] = alias
            
        elif len(line) and all([c in '01' for c in line.strip()]):
            # Lines with only characters '0' and '1' are bitmap data
            # Ensure we have as many pixels as the characters are wide.
            if not len(line)==CW:
                print('code:',code,'char:',char,'name:',name,'where:',location)
                raise ValueError('Expected bitmap row width to equal to '
                    ' chararacter width %d'%CW)
            # If a bitmap something with the same name has already been loaded,
            # raise an error. 
            if alreadydefined:
                raise ValueError('A bitmap is already defined for '+active[2])
            # Add this line to the bitmap
            bitinfo[active[2]].append(line)
          
        elif not len(line.strip())==0:
            raise ValueError('Unexpected line format: '+line)

# Convert bitmap data from '01' string to bit-packed integer
def packbits(b):
    return (2**arange(CW))@array([bi=='1' for bi in b])

"""
Bitinfo stores diacritic bitmaps `name`→[list of "01" bitmap strings]
We need to tell the code where to find each bitmap
To do that, we pack the bitmaps into an array and
record where each one starts (an how many bytes long it is)
"""
offset  = 0  # How many rows of pixel data have we packed so far? 
offsets = {} # `diacritic name` → starting index of bitmap
alldata = [] # List of all packed pixel rows
lengths = {} # `diacritic name` → number of rows in bitmap
for k,v in bitinfo.items():
    offsets[k] = offset
    lengths[k] = len(v)
    offset    += len(v)
    alldata   += [packbits(b) for b in v][::-1]

"""
Define location codes which will be used to tell the code how to render
(combine) the bitmap for each diacritic. 
"""
location_codes = {'ABOVE':0,
    'BELOW'      :1,
    'OVERLAY'    :2,
    'LEFT'       :3,
    'RIGHT'      :4,
    'ABOVE_LEFT' :5,
    'ABOVE_RIGHT':6,
    'BELOW_LEFT' :7,
    'BELOW_RIGHT':8,
    'GREEK'      :9,
    'JAPANESE'   :10}

"""
The variable `codedata` contains information needed to draw each combining
diacritic. `codedata` is a map from an integer index in 0..255 to a 4-tuple
of information:

- offset: index into diacritic bitmap table for this diacritic
- length: number of rows in the diacritic bitmap
- pad: number of pixels of padding for this diacritic
- location: how/where to draw diacritic relative to charavter

Iterate over all diacritic marks loaded from the file. 

- Check if diacritic is aliased. If it is, get the name of the base-diacritic 
  it is aliased to.

- Convert the unicode code-point into an offset relative to the start of the
  Combining Diacritical Marks block. If the code-point is not part of the
  Combining Diacritical Marks block, place it after the end of the block with
  a custom ID. 
  
- Combining diacritics with empty bitmap information are treated as undefined. 

- For aliases, bitmap information (offset, length) is pulled from the base-
  diacritic. Padding and location are always defined for each diacritic and
  never aliased. Aliasing an entire combining diacritic can be achieved using
  the "aliases" file, to mapp said diacritic onto existing diacritics. 
"""
defined_codes = set() # Set of diacritic codes in use
codedata      = {}    # name → (offset, length, pad, location) 
extra_codes   = []    # List of extra codes added, in order
for code, ch, name, location in all_marks:

    # Check if this diacritic is aliased to another diacritic
    lookup = aliases.get(name,name)

    # Calculate offset into "combining diacritics" block
    # Or assign as an "extra" code if from outside this block
    if (code>=BLOCK_STARTS and code<BLOCK_ENDS):
        i = code-BLOCK_STARTS
    else:
        i = len(extra_codes) + BLOCK_ENDS -BLOCK_STARTS
        extra_codes += [(code, ch, name, location)]

    # Check if this diacritic has been defined
    if not lookup in bitinfo or len(bitinfo[lookup])<=0:
        # Insert dummy info into the table if not defined
        # (double-width diacritics are not defined)
        continue

    # Bitmap location and length taken from "lookup" (may be aliased)
    # Padding/spacing information taken from "code" (not aliased)
    codedata[i] = (offsets[lookup],
        lengths[lookup],
        padinfo[code]+1,
        location_codes[location])
    defined_codes.add(i)

"""
Diacritics from the "combining diacritics" unicode block are used as 
trasformations. Define their names here. 
"""
SRC += '\n'
for i in range(BLOCK_STARTS,BLOCK_ENDS):
    varname = unicodedata.name(chr(i)).replace(' ','_').ljust(48)
    SRC+='#define %s (0x%X)\n'%(varname,i-BLOCK_STARTS)
for i,(j,ch,n,l) in enumerate(extra_codes):
    #varname = unicodedata.name(ch).replace(' ','_').ljust(36)#.replace('-','_')
    varname = ('COMBINING_'+n.replace('-','_').replace(' ','_')).ljust(48)
    SRC+='#define %s (0x%X)\n'%(varname,i+BLOCK_ENDS-BLOCK_STARTS)
SRC += '\n'
"""
Write out some summary information
"""
a = np.min([*defined_codes])
b = np.max([*defined_codes])+1
l = b-a
SRC += '// Defined codes range from 0x300+ %d..%d\n'%(a,b)
if len(extra_codes):
    SRC += '// The following extra codes were defined:\n'
    for i,(j,ch,n,loc) in enumerate(extra_codes):
        SRC += '// 0x%X → %d; %s (%s)\n'%(j,i,n,loc)
"""
Pack information for how to read each diacritic into a byte array. 
- First byte store offset into concatenated diacritics bitmaps. 
- Second byte packs multiple flags. 
  - Low 4 bits are a location code
  - Next 2 bits are padding (0-3 → -1, 0, 1, 2)
  - High 2 bites are the number of rows in diacritic bitmap (0-3 → 1 2 3 4)
"""
bytedata = zeros(l*2,'u8')
for i in range(a,b):
    bitmap_starts,nrows,pad,loc = codedata.get(i,(0xff,0,0,0))
    byte1 = bitmap_starts & 0xff
    byte2 = (((nrows-1)&0b11)<<6) | ((pad&0b11)<<4) | (loc&0b1111)
    bytedata[(i-a)*2:(i-a+1)*2] = [byte1,byte2]
"""
Prepare C source code
- #define each location code
- #define 0xFF as an "undefined" diacritic
- #define MAX_DIACRITIC_CODE as the last supported index
- Store bitmap rows in `diacritic_bitmaps`
- Store diacritic info codes in `diacritic_info`
- Add source code for combining diacritics
"""
# Define location codes in source code
nq = len('BELOW_RIGHT')
for k,v in location_codes.items():
    SRC+='#define %s (%d)\n'%(k.ljust(nq),v)
SRC+='#define UNDEFINED (0xFF)\n'
SRC+='#define MAX_DIACRITIC_CODE (%d)\n'%(b-1)
SRC+='''
// Diacritic bitmaps are organized into rows, with leftmost pixel in the lowest
// -order bit. Bitmaps of varying height are packed consecutively. To retrieve
// a bitmap, unpack the information in the `diacritic_info' array.
'''
SRC+=pack_array(alldata,'diacritic_bitmaps',)
SRC+='''
// The `diacritic_info` array decribes diacritics, starting at 0x300, in two-
// byte codes. The first byte is the starting index for the bitmap information
// in `diacritic_bitmaps`, or 0xFF is the diacritic is not supported. The
// second byte contains the height (minus 1), padding (1=no padding), and
// location (see #defined location codes above), packed into 2, 2, and 4 bits,
// respectively.
'''
SRC+=pack_array(bytedata,'diacritic_info')

# Check we're not wasting space using a dense packing
assert (len(alldata) + len(bytedata)) < ((b-a)*4)
SRC+='''\n\n\n
////////////////////////////////////////////////////////////////////////////////
/** Stamp combining diacritic over previously drawn character
 */
void stamp_diacritic(byte index,byte nrow,byte pad,byte location) {
  
  // Get diacritic bitmap
  byte rowdata[nrow];
  for (int i=0; i<nrow; i++)
    rowdata[i]=pgm_read_byte(diacritic_bitmaps+index+i);
  
  // Patch for now
  if (location==JAPANESE) location=ABOVE; 
  
  // Hmm, need to clean up character bitmap
  for (byte i=0; i<CH; i++) char_bitmap[i]&=0b111111;
  
  if (location==GREEK) {
    // Greek breathing marks are above for lower-case and above-left for upper-
    // case. Handle this by routing to ABOVE or ABOVE_LEFT depending on 
    // character height. Get height by starting at top, and moving down until
    // a non-empty row is found.
    int i=CH-1;
    while (char_bitmap[i]==0 && i>0) i--;
    location = i>MIDLINE? ABOVE_LEFT : ABOVE;
  }
  if (location==ABOVE_RIGHT || location==BELOW_RIGHT) {
    // Move the mark as far right as possible. 
    // Find rightmost column of diacritic bitmap
    byte mask = 0;
    int i=0;
    for (; i<nrow; i++) mask |= rowdata[i];
    mask <<= (8-CW);
    byte counter = 0;
    // Shift left until we get a 1 in the top bit
    while ((int8_t)(mask)>0) {mask<<=1; counter++;}
    // "Counter" now tells us how many bits we need to shift to meet right column
    for (i=0; i<nrow; i++) rowdata[i]<<=counter;
    // Reduce to the ABOVE/BELOW case
    location = (location==ABOVE_RIGHT)? ABOVE: BELOW;
  }
  else if (location==ABOVE_LEFT || location==BELOW_LEFT ) {
    // Move mark as far left as possible
    byte mask = 0;
    int i=0;
    for (; i<nrow; i++) mask |= rowdata[i];
    byte counter = 0;
    // Shift right until we get a 1 in the top bit
    while (mask) {mask>>=1; counter++;}
    // "Counter" now tells us how many bits we need to shift to meet right column
    for (i=0; i<nrow; i++) rowdata[i]>>=counter;
    location = (location==ABOVE_RIGHT)? ABOVE: BELOW;
  }
  if (location==ABOVE) {
    // Find top of character
    int i=CH-1;
    while (i>=MIDLINE && !char_bitmap[i]) i--;
    // Handle i,j as special cases
    if (char_bitmap[i]==0b00001000 && char_bitmap[i-1]==0) {
      // diacritics overwrite the tittle on these
      char_bitmap[i] = 0;
      while (i>=MIDLINE && !char_bitmap[i]) i--;
    }
    // i will stop at first non-empty row
    // ideally, diacritic should be placed above this
    // pad matters
    // pad 0 = overlap top
    // pad 1 = abut top
    // pad 2 = leave spacing
    byte diacritic_start_row = i+pad;
    int last_row = (nrow-1)+diacritic_start_row;
    if (last_row>=CH) {
      // Not enough space
      int need_space = last_row - (CH-1);
      while (need_space>0 && SUCCESS==shorten_down_top()                      ) {need_space--; diacritic_start_row--;}
      while (need_space>0 && SUCCESS==nudge_down_top()                        ) {need_space--; diacritic_start_row--;}
      while (need_space>0 && SUCCESS==smash_diacritics_down_top_conservative()) {need_space--; diacritic_start_row--;}
      while (need_space>0 && SUCCESS==smash_diacritics_down_top_aggressive()  ) {need_space--; diacritic_start_row--;}
      while (need_space>0 && pad>0) {pad--; need_space--; diacritic_start_row--;}
    } else if (i==MIDLINE-1) {
      byte isempty = 1;
      do {
        if (char_bitmap[i]) {
          isempty = 0;
          break;
        }
        i--;
      } while (i>=0);
      if (isempty) diacritic_start_row = CH - 1 - nrow;
    
    }
    // We might run out of space, for now just stop drawing if this happens
    for (int i=0; i<nrow; i++) {
      if (i+diacritic_start_row >= CH) break;
      char_bitmap[i+diacritic_start_row] |= rowdata[i];
    }
  }
  else if (location==BELOW) {
    // Find base of character
    int i=0;
    while (i<CH && !char_bitmap[i]) i++;
    if (i < nrow + pad - 1) {
      int need_space = nrow + pad - 1 - i - 2;
      while (need_space>0 && SUCCESS==shorten_up_base()                      ) need_space--;
      while (need_space>0 && SUCCESS==nudge_up_base()                        ) need_space--;
      while (need_space>0 && SUCCESS==smash_diacritics_up_base_conservative()) need_space--;
      while (need_space>0 && SUCCESS==smash_diacritics_up_base_aggressive()  ) need_space--;
      while (need_space>0 && pad>0) {pad--; need_space--;}
    }
    byte r = 0;
    for (int i=0; i<nrow; i++) {if (r+i>=CH) break; char_bitmap[r+i] |= rowdata[i];}
  }
  else if (location==OVERLAY) for (int i=0; i<nrow; i++) char_bitmap[MIDLINE+i-nrow/2] |= rowdata[i];
}

////////////////////////////////////////////////////////////////////////////////
// Combine mark from the combining diacritics unicode block
void combine_diacritic(byte diacritic_index) {
  if (diacritic_index>MAX_DIACRITIC_CODE) return;
  byte index = pgm_read_byte(diacritic_info + diacritic_index*2);
  if (index==UNDEFINED) return;
  byte info = pgm_read_byte(diacritic_info + diacritic_index*2 + 1);
  byte loc  = info & 0b1111;
  byte pad  = (info>>4) & 0b11;
  byte nrow = ((info>>6) & 0b11) + 1;
  stamp_diacritic(index,nrow,pad,loc);
}

////////////////////////////////////////////////////////////////////////////////
/** Handling combining diacritic. 
 *  There must be a recently-drawn charater with which to combine. 
 *  If there isn't, treat it as combining with an empty space. 
 */
int _combiningdiacriticalmarks(unsigned int c) {
  if (combining_ok) {row=prev_row; col=prev_col;}
  else clear_bitmap();
  combine_diacritic(c);
  new_combining_ok = 1;
  return LOADED;
}
'''

# Write header file
SRC+='\n\n#endif // %s\n'%headername
with open(diacritics_filename,'wb') as f:
    f.write(SRC.encode('utf8'))
    f.flush()
    f.close()

